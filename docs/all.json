{"shell":true,"revision":"42b5d025b9d5e01b2c96ca88586408a9dac208f8","objects":[{"type":null,"source":"lib/quark.ex:2","object_type":"ModuleObject","moduledoc":"For convenience, many of the most common combinators are available here and given\nfirendlier names.\n\nDue to performance reasons, many of the combinators are given non-combinatory\nimplementations (ie: not everything is expressed in terms `s` and `k`)\n","module":"Elixir.Quark","id":"Quark"},{"type":null,"source":"lib/quark/bckw.ex:2","object_type":"ModuleObject","moduledoc":"The classic [BCKW combinators](https://en.wikipedia.org/wiki/B,_C,_K,_W_system).\nA similar idea to `SKI`, but with different primitives.\n","module":"Elixir.Quark.BCKW","id":"Quark.BCKW"},{"type":null,"source":"lib/quark/compose.ex:2","object_type":"ModuleObject","moduledoc":"Function composition is taking two functions, and joining them together to create\na new function. For example:\n\n```elixir\n\niex> sum_plus_one = compose([&(&1 + 1), &Enum.sum/1])\niex> sum_plus_one.([1,2,3])\n7\n\n```\n\nIn this case, we have joined `Enum.sum` with a function that adds one, to create\na new function that takes a list, sums it, and adds one.\n\nNote that composition normally applies _from right to left_, though `Quark`\nprovides the opposite in the form of `*_forward` functions.\n","module":"Elixir.Quark.Compose","id":"Quark.Compose"},{"type":null,"source":"lib/quark/curry.ex:2","object_type":"ModuleObject","moduledoc":"[Currying](https://en.wikipedia.org/wiki/Currying) breaks up a function into a\nseries of unary functions that apply their arguments to some inner\nn-ary function. This is a convenient way to achieve a general and flexble\npartial application on any curried function.\n","module":"Elixir.Quark.Curry","id":"Quark.Curry"},{"type":null,"source":"lib/quark/fixed_point.ex:2","object_type":"ModuleObject","moduledoc":"Fixed point combinators generalize the idea of a recursive function. This can\nbe used to great effect, simplifying many definitions.\n\nFor example, here is the factorial function written in terms of `y/1`:\n\n```elixir\n\niex> fac = fn fac ->\n...>   fn\n...>     0 -> 0\n...>     1 -> 1\n...>     n -> n * fac.(n - 1)\n...>   end\n...> end\niex> factorial = y fac\niex> factorial.(9)\n362880\n\n```\n\nThe resulting functions will always be curried\n\n```elixir\n\niex> import Quark.SKI, only: [s: 3]\niex> one_run = y(&s/3)\niex> {_, arity} = :erlang.fun_info(one_run, :arity)\niex> arity\n1\n\n```\n\n","module":"Elixir.Quark.FixedPoint","id":"Quark.FixedPoint"},{"type":null,"source":"lib/quark/partial.ex:2","object_type":"ModuleObject","moduledoc":"Provide curried functions, that can also be partially bound without dot notation.\nPartially applying a function will always return a fully-curried function.\n\nPlease note that these will use all of the arities up to the defined function.\nFor example, `defpartial foo(a, b, c), do: a + b + c` will generate `foo/0`, `foo/1`,\n`foo/2`, and `foo/3`. If you need to use an arity in the range below the original\nfunction, fall back to `defcurry` and partially apply manually.\n","module":"Elixir.Quark.Partial","id":"Quark.Partial"},{"type":null,"source":"lib/quark/ski.ex:2","object_type":"ModuleObject","moduledoc":"The classic [SKI system](https://en.wikipedia.org/wiki/SKI_combinator_calculus)\ncombinators. `s` and `k` alone can be used to express any algorithm,\nthough generally not efficiently.\n","module":"Elixir.Quark.SKI","id":"Quark.SKI"},{"type":"protocol","source":"lib/quark/sequence.ex:2","object_type":"ModuleObject","moduledoc":"","module":"Elixir.Quark.Sequence","id":"Quark.Sequence"},{"type":"impl","source":"lib/quark/sequence.ex:60","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Quark.Sequence.Integer","id":"Quark.Sequence.Integer"},{"type":"def","source":"lib/quark.ex:13","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"<|>","module_id":"Quark","id":"<|>/2","doc":"See `Quark.Compose.<|>/2`.","arity":2},{"type":"def","source":"lib/quark.ex:12","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"compose","module_id":"Quark","id":"compose/2","doc":"See `Quark.Compose.compose/2`.","arity":2},{"type":"def","source":"lib/quark.ex:24","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"constant","module_id":"Quark","id":"constant/2","doc":"See `Quark.SKI.k/2`.","arity":2},{"type":"def","source":"lib/quark.ex:25","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"first","module_id":"Quark","id":"first/2","doc":"See `Quark.SKI.k/2`.","arity":2},{"type":"def","source":"lib/quark.ex:15","signature":[["f",[],null]],"object_type":"FunctionObject","name":"fix","module_id":"Quark","id":"fix/1","doc":"See `Quark.FixedPoint.fix/1`.","arity":1},{"type":"def","source":"lib/quark.ex:21","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"flip","module_id":"Quark","id":"flip/2","doc":"See `Quark.BCKW.c/2`.","arity":2},{"type":"def","source":"lib/quark.ex:22","signature":[["x",[],null]],"object_type":"FunctionObject","name":"id","module_id":"Quark","id":"id/1","doc":"See `Quark.SKI.i/1`.","arity":1},{"type":"def","source":"lib/quark.ex:47","signature":[],"object_type":"FunctionObject","name":"m","module_id":"Quark","id":"m/0","doc":"Apply a function to itself\n\n```elixir\n\niex> import Quark, only: [m: 1]\niex> add_one = fn x -> x + 1 end\niex> add_two = m(add_one)\niex> add_two.(8)\n10\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark.ex:62","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"m","module_id":"Quark","id":"m/1","doc":null,"arity":1},{"type":"def","source":"lib/quark.ex:17","signature":[["x",[],null]],"object_type":"FunctionObject","name":"origin","module_id":"Quark","id":"origin/1","doc":"See `Quark.Sequence.origin/1`.","arity":1},{"type":"def","source":"lib/quark.ex:19","signature":[["x",[],null]],"object_type":"FunctionObject","name":"pred","module_id":"Quark","id":"pred/1","doc":"See `Quark.Sequence.pred/1`.","arity":1},{"type":"def","source":"lib/quark.ex:27","signature":[],"object_type":"FunctionObject","name":"second","module_id":"Quark","id":"second/0","doc":"Opposite of `first` (the `k` combinator).\n\nReturns the *second* of two arguments. Can be used to repeatedly apply the same value\nin functions such as folds.\n\n```elixir\n\niex> Quark.second(43, 42)\n42\n\niex> Enum.reduce([1,2,3], [], &Quark.second/2)\n[]\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark.ex:45","signature":[["a",[],null]],"object_type":"FunctionObject","name":"second","module_id":"Quark","id":"second/1","doc":null,"arity":1},{"type":"def","source":"lib/quark.ex:45","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"second","module_id":"Quark","id":"second/2","doc":null,"arity":2},{"type":"def","source":"lib/quark.ex:68","signature":[],"object_type":"FunctionObject","name":"self_apply","module_id":"Quark","id":"self_apply/0","doc":"See `Quark.m/0`.","arity":0},{"type":"def","source":"lib/quark.ex:69","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"self_apply","module_id":"Quark","id":"self_apply/1","doc":"See `Quark.m/1`.","arity":1},{"type":"def","source":"lib/quark.ex:18","signature":[["x",[],null]],"object_type":"FunctionObject","name":"succ","module_id":"Quark","id":"succ/1","doc":"See `Quark.Sequence.succ/1`.","arity":1},{"type":"def","source":"lib/quark/bckw.ex:10","signature":[],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/0","doc":"Normal (binary) function composition\n\n```elixir\n\niex> sum_plus_one = b(&(&1 + 1), &Enum.sum/1)\niex> [1,2,3] |> sum_plus_one.()\n7\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:23","signature":[["x",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/bckw.ex:23","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/bckw.ex:23","signature":[["x",[],null],["y",[],null],["z",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/3","doc":null,"arity":3},{"type":"def","source":"lib/quark/bckw.ex:25","signature":[],"object_type":"FunctionObject","name":"c","module_id":"Quark.BCKW","id":"c/0","doc":"Reverse (first) two arguments (`flip`)\n\n```elixir\n\niex> c(&div/2).(1, 2)\n2\n\niex> reverse_concat = c(&Enum.concat/2)\niex> reverse_concat.([1,2,3], [4,5,6])\n[4,5,6,1,2,3]\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:41","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"c","module_id":"Quark.BCKW","id":"c/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/bckw.ex:43","signature":[],"object_type":"FunctionObject","name":"w","module_id":"Quark.BCKW","id":"w/0","doc":"Apply the same argument to a functon twice\n\n```elixir\n\niex> repeat = w(&Enum.concat/2)\niex> repeat.([1,2])\n[1,2,1,2]\n\niex> w(&Enum.zip/2).([1,2,3])\n[{1, 1}, {2, 2}, {3, 3}]\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:59","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"w","module_id":"Quark.BCKW","id":"w/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/compose.ex:55","signature":[["g",[],null],["f",[],null]],"object_type":"FunctionObject","name":"<|>","module_id":"Quark.Compose","id":"<|>/2","doc":"Infix compositon operator\n\n```elixir\n\niex> sum_plus_one = fn x -> x + 1 end <|> &Enum.sum/1\niex> sum_plus_one.([1,2,3])\n7\n\niex> add_one = &(&1 + 1)\niex> piped = [1,2,3] |> Enum.sum |> add_one.()\niex> composed = [1,2,3] |> ((add_one <|> &Enum.sum/1)).()\niex> piped == composed\ntrue\n\n```\n\n","arity":2},{"type":"def","source":"lib/quark/compose.ex:53","signature":[],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/0","doc":null,"arity":0},{"type":"def","source":"lib/quark/compose.ex:39","signature":[["func_list",[],null]],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/1","doc":"Function composition, from the tail of the list to the head\n\n```elixir\n\niex> sum_plus_one = compose([&(&1 + 1), &Enum.sum/1])\niex> [1,2,3] |> sum_plus_one.()\n7\n\n```\n\n","arity":1},{"type":"def","source":"lib/quark/compose.ex:24","signature":[["g",[],null],["f",[],null]],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/2","doc":"Function composition\n\n```elixir\n\niex> sum_plus_one = compose(&(&1 + 1), &Enum.sum/1)\niex> [1,2,3] |> sum_plus_one.()\n7\n\n```\n\n","arity":2},{"type":"def","source":"lib/quark/compose.ex:76","signature":[],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/0","doc":"Function composition, from the back of the lift to the front\n\n```elixir\n\niex> sum_plus_one = compose_forward(&(Enum.sum(&1)), &(&1 + 1))\niex> [1,2,3] |> sum_plus_one.()\n7\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/compose.ex:89","signature":[["f",[],null]],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/compose.ex:89","signature":[["f",[],null],["g",[],null]],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/compose.ex:92","signature":[],"object_type":"FunctionObject","name":"compose_list_forward","module_id":"Quark.Compose","id":"compose_list_forward/0","doc":"Compose functions, from the head of the list of functions. The is the reverse\norder versus what one would normally expect (left to right rather than right to left).\n\n```elixir\n\niex> sum_plus_one = compose_list_forward([&Enum.sum/1, &(&1 + 1)])\niex> [1,2,3] |> sum_plus_one.()\n7\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/compose.ex:106","signature":[["func_list",[],null]],"object_type":"FunctionObject","name":"compose_list_forward","module_id":"Quark.Compose","id":"compose_list_forward/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/curry.ex:9","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"curry","module_id":"Quark.Curry","id":"curry/1","doc":"This allows you to curry a function at runtime, rather than upon definition.\n\n```elixir\n\niex> curried_reduce_3 = curry &Enum.reduce/3\niex> {_, arity} = :erlang.fun_info(curried_reduce_3, :arity)\niex> arity\n1\n\niex> curried_reduce_3 = curry &Enum.reduce/3\niex> import Quark.Curry\niex> curried_reduce_3.([1,2,3]).(42).(&(&1 + &2))\n48\n\n```\n\n","arity":1},{"type":"defmacro","source":"lib/quark/curry.ex:100","signature":[["head",[],null],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defcurry","module_id":"Quark.Curry","id":"defcurry/2","doc":"Define a curried function\n","arity":2},{"type":"defmacro","source":"lib/quark/curry.ex:111","signature":[["head",[],null],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defcurryp","module_id":"Quark.Curry","id":"defcurryp/2","doc":"Define a curried private function\n","arity":2},{"type":"def","source":"lib/quark/curry.ex:40","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"uncurry","module_id":"Quark.Curry","id":"uncurry/1","doc":"Convert a curried function to a function on pairs\n\n```elixir\n\niex> curried_add = fn x -> (fn y -> x + y end) end\niex> add = uncurry curried_add\niex> add.(1,2)\n3\n\n```\n\n","arity":1},{"type":"def","source":"lib/quark/curry.ex:56","signature":[["fun",[],null],["arg",[],null]],"object_type":"FunctionObject","name":"uncurry","module_id":"Quark.Curry","id":"uncurry/2","doc":"Apply an argument to a function\n\n```elixir\n\niex> add_one = &(&1 + 1)\niex> uncurry(add_one, 1)\n2\n\niex> curried_add = fn x -> (fn y -> x + y end) end\niex> add_one = uncurry(curried_add, 1)\niex> add_one.(3)\n4\n\n```\n\n","arity":2},{"type":"def","source":"lib/quark/fixed_point.ex:40","signature":[],"object_type":"FunctionObject","name":"fix","module_id":"Quark.FixedPoint","id":"fix/0","doc":"See `Quark.FixedPoint.y/0`.","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:41","signature":[["a",[],null]],"object_type":"FunctionObject","name":"fix","module_id":"Quark.FixedPoint","id":"fix/1","doc":"See `Quark.FixedPoint.y/1`.","arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:69","signature":[],"object_type":"FunctionObject","name":"turing","module_id":"Quark.FixedPoint","id":"turing/0","doc":"Alan Turing's fix-point combinator. This is the call-by-value formulation.\n\n```elixir\n\niex> fac = fn fac ->\n...>   fn\n...>     0 -> 0\n...>     1 -> 1\n...>     n -> n * fac.(n - 1)\n...>   end\n...> end\niex> factorial = turing(fac)\niex> factorial.(9)\n362880\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:89","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"turing","module_id":"Quark.FixedPoint","id":"turing/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:43","signature":[],"object_type":"FunctionObject","name":"y","module_id":"Quark.FixedPoint","id":"y/0","doc":"The famous Y-combinator. The resulting function will always be curried.\n\n```elixir\n\niex> fac = fn fac ->\n...>   fn\n...>     0 -> 0\n...>     1 -> 1\n...>     n -> n * fac.(n - 1)\n...>   end\n...> end\niex> factorial = y(fac)\niex> factorial.(9)\n362880\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:63","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"y","module_id":"Quark.FixedPoint","id":"y/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:97","signature":[],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/0","doc":"A [normal order](https://en.wikipedia.org/wiki/Evaluation_strategy#Normal_order) fixed point\n\n```elixir\n\niex> fac = fn fac ->\n...>   fn\n...>     0 -> 0\n...>     1 -> 1\n...>     n -> n * fac.(n - 1)\n...>   end\n...> end\niex> factorial = z(fac)\niex> factorial.(9)\n362880\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:117","signature":[["g",[],null]],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:117","signature":[["g",[],null],["v",[],null]],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/2","doc":null,"arity":2},{"type":"defmacro","source":"lib/quark/partial.ex:21","signature":[["arg",[],"Elixir"],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defpartial","module_id":"Quark.Partial","id":"defpartial/2","doc":"A convenience on `defcurry`. Generates a series of partially-bound applications\nof a fully-curried function, for all arities _at and below_ the user-specified\narity. For instance, `defpartial add(a,b), do: a + b` will generate `add/0`,\n`add/1` and `add/2`.\n\n```elixir\n\ndefpartialp minus(a, b, c), do: a - b - c\n\nminus(3, 2, 1)\n# => 0\n\nminus.(3).(2).(1)\n# => 0\n\nbelow_ten = minus(5)\nbelow_ten.(2, 1)\n# => 7\n\nbelow_five = minus(20, 15)\nbelow_five.(2)\n# => 3\n\n```\n\n","arity":2},{"type":"defmacro","source":"lib/quark/partial.ex:62","signature":[["arg",[],"Elixir"],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defpartialp","module_id":"Quark.Partial","id":"defpartialp/2","doc":"`defpartial`, but generates private functions\n\n```elixir\n\ndefpartialp minus(a, b, c), do: a - b - c\n\nminus(3, 2, 1)\n# => 0\n\nminus.(3).(2).(1)\n# => 0\n\nbelow10 = minus(5)\nbelow10.(2, 1)\n# => 7\n\nbelow5 = minus(10, 5)\nbelow5.(2)\n# => 3\n\n```\n\n","arity":2},{"type":"def","source":"lib/quark/ski.ex:10","signature":[],"object_type":"FunctionObject","name":"i","module_id":"Quark.SKI","id":"i/0","doc":"The identity combinator\n\n```elixir\n\niex> i(1)\n1\n\niex> i(\"identity combinator\")\n\"identity combinator\"\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:25","signature":[["x",[],null]],"object_type":"FunctionObject","name":"i","module_id":"Quark.SKI","id":"i/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:27","signature":[],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/0","doc":"The constant (\"Konstant\") combinator. Returns the first argument, unchanged, and\ndiscards the second argument. Can be used to repeatedly apply the same value\nin functions such as folds.\n\n```elixir\n\niex> k(1, 2)\n1\n\niex> k(\"happy\", \"sad\")\n\"happy\"\n\niex> Enum.reduce([1,2,3], [42], &k/2)\n3\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:47","signature":[["x",[],null]],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:47","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/ski.ex:49","signature":[],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/0","doc":"The \"substitution\" combinator. Applies the last argument to the first two, and then\nthe first two to each other.\n\n```elixir\n\niex> add = &(&1 + &2)\niex> double = &(&1 * 2)\niex> s(add, double, 8)\n24\n\n```\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:64","signature":[["x",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:64","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/ski.ex:64","signature":[["x",[],null],["y",[],null],["z",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/3","doc":null,"arity":3},{"type":"def","source":"lib/quark/sequence.ex:1","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__protocol__","module_id":"Quark.Sequence","id":"__protocol__/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:5","signature":[["specimen",[],null]],"object_type":"FunctionObject","name":"origin","module_id":"Quark.Sequence","id":"origin/1","doc":"The beginning of the sequence.\n\nFor instance, integers are generally thought of as centering around 0\n\n```elixir\n\niex> origin(9)\n0\n\n```\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:40","signature":[["element",[],null]],"object_type":"FunctionObject","name":"pred","module_id":"Quark.Sequence","id":"pred/1","doc":"The `pred`essor in the sequence.\n\nFor integers, this is the number below.\n\n```elixir\n\niex> pred(10)\n9\n\niex> 42 |> origin |> pred |> pred\n-2\n\n```\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:21","signature":[["element",[],null]],"object_type":"FunctionObject","name":"succ","module_id":"Quark.Sequence","id":"succ/1","doc":"The `succ`essor in sequence.\n\nFor integers, this is the number above.\n\n```elixir\n\niex> succ(1)\n2\n\niex> 10 |> origin |> succ |> succ\n2\n\n```\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:60","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Quark.Sequence.Integer","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:61","signature":[["num",[],null]],"object_type":"FunctionObject","name":"origin","module_id":"Quark.Sequence.Integer","id":"origin/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:63","signature":[["num",[],null]],"object_type":"FunctionObject","name":"pred","module_id":"Quark.Sequence.Integer","id":"pred/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:62","signature":[["num",[],null]],"object_type":"FunctionObject","name":"succ","module_id":"Quark.Sequence.Integer","id":"succ/1","doc":false,"arity":1}],"language":"elixir","git_repo_url":"https://github.com/robot-overlord/quark.git","client_version":"0.4.0","client_name":"inch_ex","branch_name":"master","args":[]}