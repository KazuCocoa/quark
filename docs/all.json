{"shell":true,"revision":"0ad58139943ee66cd40d2a8cf731a9adbf461f29","objects":[{"type":null,"source":"lib/quark.ex:2","object_type":"ModuleObject","moduledoc":"Top-level module. Provides a convenient `use` macro for importing the most\ncommonly used functions and macros.\n\nDue to performance reasons, many of the combinators are given non-combinatory\nimplementations (ie: not everything is expressed in terms `s` and `k`)\n","module":"Elixir.Quark","id":"Quark"},{"type":null,"source":"lib/quark/bckw.ex:2","object_type":"ModuleObject","moduledoc":"The classic [BCKW combinators](https://wikipedia.org/wiki/B,_C,_K,_W_system).\nA similar idea to `SKI`, but with different primitives.\n","module":"Elixir.Quark.BCKW","id":"Quark.BCKW"},{"type":null,"source":"lib/quark/compose.ex:2","object_type":"ModuleObject","moduledoc":"Function composition is taking two functions, and joining them together to\ncreate a new function. For example:\n\n## Examples\n\n    iex> sum_plus_one = compose([&(&1 + 1), &Enum.sum/1])\n    ...> sum_plus_one.([1,2,3])\n    7\n\nIn this case, we have joined `Enum.sum` with a function that adds one,\nto create a new function that takes a list, sums it, and adds one.\n\nNote that composition normally applies _from right to left_, though `Quark`\nprovides the opposite in the form of `*_forward` functions.\n","module":"Elixir.Quark.Compose","id":"Quark.Compose"},{"type":null,"source":"lib/quark/curry.ex:2","object_type":"ModuleObject","moduledoc":"[Currying](https://en.wikipedia.org/wiki/Currying) breaks up a function into a\nseries of unary functions that apply their arguments to some inner\nn-ary function. This is a convenient way to achieve a general and flexible\npartial application on any curried function.\n","module":"Elixir.Quark.Curry","id":"Quark.Curry"},{"type":null,"source":"lib/quark/fixed_point.ex:2","object_type":"ModuleObject","moduledoc":"Fixed point combinators generalize the idea of a recursive function. This can\nbe used to great effect, simplifying many definitions.\n\nFor example, here is the factorial function written in terms of `y/1`:\n\n    iex> fac = fn fac ->\n    ...>   fn\n    ...>     0 -> 0\n    ...>     1 -> 1\n    ...>     n -> n * fac.(n - 1)\n    ...>   end\n    ...> end\n    ...> factorial = y fac\n    ...> factorial.(9)\n    362880\n\nThe resulting functions will always be curried\n\n    iex> import Quark.SKI, only: [s: 3]\n    ...> one_run = y(&s/3)\n    ...> {_, arity} = :erlang.fun_info(one_run, :arity)\n    ...> arity\n    1\n\n","module":"Elixir.Quark.FixedPoint","id":"Quark.FixedPoint"},{"type":null,"source":"lib/quark/m.ex:2","object_type":"ModuleObject","moduledoc":"The self-applyication combinator","module":"Elixir.Quark.M","id":"Quark.M"},{"type":null,"source":"lib/quark/partial.ex:2","object_type":"ModuleObject","moduledoc":"Provide curried functions, that can also be partially bound without\ndot notation. Partially applying a function will always return a\nfully-curried function.\n\nPlease note that these will use all of the arities up to the defined function.\n\nFor instance:\n\n    defpartial foo(a, b, c), do: a + b + c\n    #=> foo/0, foo/1, foo/2, and foo/3\n\nIf you need to use an arity in the range below the original\nfunction, fall back to `defcurry` and partially apply manually.\n","module":"Elixir.Quark.Partial","id":"Quark.Partial"},{"type":null,"source":"lib/quark/ski.ex:2","object_type":"ModuleObject","moduledoc":"The classic [SKI](https://en.wikipedia.org/wiki/SKI_combinator_calculus)\nsystem of combinators. `s` and `k` alone can be used to express any algorithm,\nthough generally not efficiently.\n","module":"Elixir.Quark.SKI","id":"Quark.SKI"},{"type":"protocol","source":"lib/quark/sequence.ex:2","object_type":"ModuleObject","moduledoc":"A protocol for stepping through ordered enumerables\n","module":"Elixir.Quark.Sequence","id":"Quark.Sequence"},{"type":"impl","source":"lib/quark/sequence.ex:55","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Quark.Sequence.Integer","id":"Quark.Sequence.Integer"},{"type":"def","source":"lib/quark/bckw.ex:10","signature":[],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/0","doc":"Normal (binary) function composition\n\n## Examples\n\n    iex> sum_plus_one = b(&(&1 + 1), &Enum.sum/1)\n    iex> [1,2,3] |> sum_plus_one.()\n    7\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:21","signature":[["x",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/bckw.ex:21","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/bckw.ex:21","signature":[["x",[],null],["y",[],null],["z",[],null]],"object_type":"FunctionObject","name":"b","module_id":"Quark.BCKW","id":"b/3","doc":null,"arity":3},{"type":"def","source":"lib/quark/bckw.ex:23","signature":[],"object_type":"FunctionObject","name":"c","module_id":"Quark.BCKW","id":"c/0","doc":"Reverse (first) two arguments (`flip`). Aliased as `flip`.\n\n## Examples\n\n    iex> c(&div/2).(1, 2)\n    2\n\n    iex> reverse_concat = c(&Enum.concat/2)\n    ...> reverse_concat.([1,2,3], [4,5,6])\n    [4,5,6,1,2,3]\n\n    iex> flip(&div/2).(1, 2)\n    2\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:40","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"c","module_id":"Quark.BCKW","id":"c/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/bckw.ex:42","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"flip","module_id":"Quark.BCKW","id":"flip/1","doc":"See `Quark.BCKW.c/1`.","arity":1},{"type":"def","source":"lib/quark/bckw.ex:44","signature":[],"object_type":"FunctionObject","name":"w","module_id":"Quark.BCKW","id":"w/0","doc":"Apply the same argument to a functon twice\n\n## Examples\n\n    iex> repeat = w(&Enum.concat/2)\n    iex> repeat.([1,2])\n    [1,2,1,2]\n\n    iex> w(&Enum.zip/2).([1,2,3])\n    [{1, 1}, {2, 2}, {3, 3}]\n\n","arity":0},{"type":"def","source":"lib/quark/bckw.ex:58","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"w","module_id":"Quark.BCKW","id":"w/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/compose.ex:49","signature":[["g",[],null],["f",[],null]],"object_type":"FunctionObject","name":"<|>","module_id":"Quark.Compose","id":"<|>/2","doc":"Infix compositon operator\n\n## Examples\n\n    iex> sum_plus_one = fn x -> x + 1 end <|> &Enum.sum/1\n    iex> sum_plus_one.([1,2,3])\n    7\n\n    iex> add_one = &(&1 + 1)\n    iex> piped = [1,2,3] |> Enum.sum |> add_one.()\n    iex> composed = [1,2,3] |> ((add_one <|> &Enum.sum/1)).()\n    iex> piped == composed\n    true\n\n","arity":2},{"type":"def","source":"lib/quark/compose.ex:47","signature":[],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/0","doc":null,"arity":0},{"type":"def","source":"lib/quark/compose.ex:35","signature":[["func_list",[],null]],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/1","doc":"Function composition, from the tail of the list to the head\n\n## Examples\n\n    iex> sum_plus_one = compose([&(&1 + 1), &Enum.sum/1])\n    ...> [1,2,3] |> sum_plus_one.()\n    7\n\n","arity":1},{"type":"def","source":"lib/quark/compose.ex:22","signature":[["g",[],null],["f",[],null]],"object_type":"FunctionObject","name":"compose","module_id":"Quark.Compose","id":"compose/2","doc":"Function composition\n\n## Examples\n\n    iex> sum_plus_one = compose(&(&1 + 1), &Enum.sum/1)\n    iex> [1,2,3] |> sum_plus_one.()\n    7\n\n","arity":2},{"type":"def","source":"lib/quark/compose.ex:68","signature":[],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/0","doc":"Function composition, from the back of the lift to the front\n\n## Examples\n\n    iex> sum_plus_one = compose_forward(&(Enum.sum(&1)), &(&1 + 1))\n    iex> [1,2,3] |> sum_plus_one.()\n    7\n\n","arity":0},{"type":"def","source":"lib/quark/compose.ex:79","signature":[["f",[],null]],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/compose.ex:79","signature":[["f",[],null],["g",[],null]],"object_type":"FunctionObject","name":"compose_forward","module_id":"Quark.Compose","id":"compose_forward/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/compose.ex:82","signature":[],"object_type":"FunctionObject","name":"compose_list_forward","module_id":"Quark.Compose","id":"compose_list_forward/0","doc":"Compose functions, from the head of the list of functions. The is the reverse\norder versus what one would normally expect (left-to-right rather than\nright-to-left).\n\n## Examples\n\n    iex> sum_plus_one = compose_list_forward([&Enum.sum/1, &(&1 + 1)])\n    ...> [1,2,3] |> sum_plus_one.()\n    7\n\n","arity":0},{"type":"def","source":"lib/quark/compose.ex:95","signature":[["func_list",[],null]],"object_type":"FunctionObject","name":"compose_list_forward","module_id":"Quark.Compose","id":"compose_list_forward/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/curry.ex:16","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"curry","module_id":"Quark.Curry","id":"curry/1","doc":"Curry a function at runtime, rather than upon definition\n\n## Examples\n\n    iex> curried_reduce_3 = curry &Enum.reduce/3\n    ...> {_, arity} = :erlang.fun_info(curried_reduce_3, :arity)\n    ...> arity\n    1\n\n    iex> curried_reduce_3 = curry &Enum.reduce/3\n    ...> curried_reduce_3.([1,2,3]).(42).(&(&1 + &2))\n    48\n\n","arity":1},{"type":"defmacro","source":"lib/quark/curry.ex:92","signature":[["head",[],null],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defcurry","module_id":"Quark.Curry","id":"defcurry/2","doc":"Define a curried function","arity":2},{"type":"defmacro","source":"lib/quark/curry.ex:101","signature":[["head",[],null],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defcurryp","module_id":"Quark.Curry","id":"defcurryp/2","doc":"Define a curried private function","arity":2},{"type":"def","source":"lib/quark/curry.ex:44","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"uncurry","module_id":"Quark.Curry","id":"uncurry/1","doc":"Convert a curried function to a function on pairs\n\n## Examples\n\n    iex> curried_add = fn x -> (fn y -> x + y end) end\n    iex> add = uncurry curried_add\n    iex> add.(1,2)\n    3\n\n","arity":1},{"type":"def","source":"lib/quark/curry.ex:58","signature":[["fun",[],null],["arg_list",[],null]],"object_type":"FunctionObject","name":"uncurry","module_id":"Quark.Curry","id":"uncurry/2","doc":"Apply an argument to a function\n\n## Examples\n\n    iex> add_one = &(&1 + 1)\n    ...> uncurry(add_one, 1)\n    2\n\n    iex> curried_add = fn x -> (fn y -> x + y end) end\n    ...> add_one = uncurry(curried_add, 1)\n    ...> add_one.(3)\n    4\n\n","arity":2},{"type":"def","source":"lib/quark/fixed_point.ex:32","signature":[],"object_type":"FunctionObject","name":"fix","module_id":"Quark.FixedPoint","id":"fix/0","doc":"See `Quark.FixedPoint.y/0`.","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:33","signature":[["a",[],null]],"object_type":"FunctionObject","name":"fix","module_id":"Quark.FixedPoint","id":"fix/1","doc":"See `Quark.FixedPoint.y/1`.","arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:59","signature":[],"object_type":"FunctionObject","name":"turing","module_id":"Quark.FixedPoint","id":"turing/0","doc":"Alan Turing's fix-point combinator. This is the call-by-value formulation.\n\n## Examples\n\n    iex> fac = fn fac ->\n    ...>   fn\n    ...>     0 -> 0\n    ...>     1 -> 1\n    ...>     n -> n * fac.(n - 1)\n    ...>   end\n    ...> end\n    ...> factorial = turing(fac)\n    ...> factorial.(9)\n    362880\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:77","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"turing","module_id":"Quark.FixedPoint","id":"turing/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:35","signature":[],"object_type":"FunctionObject","name":"y","module_id":"Quark.FixedPoint","id":"y/0","doc":"The famous Y-combinator. The resulting function will always be curried.\n\n## Examples\n\n   iex> fac = fn fac ->\n   ...>   fn\n   ...>     0 -> 0\n   ...>     1 -> 1\n   ...>     n -> n * fac.(n - 1)\n   ...>   end\n   ...> end\n   ...> factorial = y(fac)\n   ...> factorial.(9)\n   362880\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:53","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"y","module_id":"Quark.FixedPoint","id":"y/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:85","signature":[],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/0","doc":"A [normal order](https://wikipedia.org/wiki/Evaluation_strategy#Normal_order)\nfixed point.\n\n## Examples\n\n    iex> fac = fn fac ->\n    ...>   fn\n    ...>     0 -> 0\n    ...>     1 -> 1\n    ...>     n -> n * fac.(n - 1)\n    ...>   end\n    ...> end\n    ...> factorial = z(fac)\n    ...> factorial.(9)\n    362880\n\n","arity":0},{"type":"def","source":"lib/quark/fixed_point.ex:104","signature":[["g",[],null]],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/fixed_point.ex:104","signature":[["g",[],null],["v",[],null]],"object_type":"FunctionObject","name":"z","module_id":"Quark.FixedPoint","id":"z/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/m.ex:6","signature":[],"object_type":"FunctionObject","name":"m","module_id":"Quark.M","id":"m/0","doc":"Apply a function to itself. Also aliased as `self_apply`.\n\n## Examples\n\n    iex> add_one = fn x -> x + 1 end\n    ...> add_two = m(add_one)\n    ...> add_two.(8)\n    10\n\n","arity":0},{"type":"def","source":"lib/quark/m.ex:18","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"m","module_id":"Quark.M","id":"m/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/m.ex:24","signature":[],"object_type":"FunctionObject","name":"self_apply","module_id":"Quark.M","id":"self_apply/0","doc":"See `Quark.M.m/0`.","arity":0},{"type":"def","source":"lib/quark/m.ex:25","signature":[["fun",[],null]],"object_type":"FunctionObject","name":"self_apply","module_id":"Quark.M","id":"self_apply/1","doc":"See `Quark.M.m/1`.","arity":1},{"type":"defmacro","source":"lib/quark/partial.ex:27","signature":[["arg",[],"Elixir"],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defpartial","module_id":"Quark.Partial","id":"defpartial/2","doc":"A convenience on `defcurry`. Generates a series of partially-bound\napplications of a fully-curried function, for all arities _at and below_\nthe user-specified arity.\n\nFor instance:\n\n    defpartial add(a,b), do: a + b\n    #=> add/0, add/1, add/2.\n\n## Examples\n\n    defpartialp minus(a, b, c), do: a - b - c\n    minus(3, 2, 1)\n    0\n\n    minus.(3).(2).(1)\n    0\n\n    below_ten = minus(5)\n    below_ten.(2, 1)\n    7\n\n    below_five = minus(20, 15)\n    below_five.(2)\n    3\n\n","arity":2},{"type":"defmacro","source":"lib/quark/partial.ex:71","signature":[["arg",[],"Elixir"],["list",[],"Elixir"]],"object_type":"FunctionObject","name":"defpartialp","module_id":"Quark.Partial","id":"defpartialp/2","doc":"`defpartial`, but generates private functions\n\n## Examples\n\n    defpartialp minus(a, b, c), do: a - b - c\n    minus(3, 2, 1)\n    0\n\n    minus.(3).(2).(1)\n    0\n    below10 = minus(5)\n    below10.(2, 1)\n    7\n\n    below5 = minus(10, 5)\n    below5.(2)\n    3\n\n","arity":2},{"type":"def","source":"lib/quark/ski.ex:57","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"constant","module_id":"Quark.SKI","id":"constant/2","doc":"See `Quark.SKI.k/2`.","arity":2},{"type":"def","source":"lib/quark/ski.ex:58","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"first","module_id":"Quark.SKI","id":"first/2","doc":"See `Quark.SKI.k/2`.","arity":2},{"type":"def","source":"lib/quark/ski.ex:10","signature":[],"object_type":"FunctionObject","name":"i","module_id":"Quark.SKI","id":"i/0","doc":"The identity combinator. Also aliased as `id`.\n\n    iex> i(1)\n    1\n\n    iex> i(\"identity combinator\")\n    \"identity combinator\"\n\n    iex> [1,2,3] |> id\n    [1,2,3]\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:24","signature":[["x",[],null]],"object_type":"FunctionObject","name":"i","module_id":"Quark.SKI","id":"i/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:26","signature":[["x",[],null]],"object_type":"FunctionObject","name":"id","module_id":"Quark.SKI","id":"id/1","doc":"See `Quark.SKI.i/1`.","arity":1},{"type":"def","source":"lib/quark/ski.ex:28","signature":[],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/0","doc":"The constant (\"Konstant\") combinator. Returns the first argument unchanged,\nand discards the second argument.\n\nCan be used to repeatedly apply the same value in functions such as folds.\n\nAliased as `first` and `constant`.\n\n## Examples\n\n    iex> k(1, 2)\n    1\n\n    iex> k(\"happy\", \"sad\")\n    \"happy\"\n\n    iex> Enum.reduce([1,2,3], [42], &k/2)\n    3\n\n    iex> Enum.reduce([1,2,3], [42], &constant/2)\n    3\n\n    iex> first(1,2)\n    1\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:55","signature":[["x",[],null]],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:55","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"k","module_id":"Quark.SKI","id":"k/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/ski.ex:80","signature":[],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/0","doc":"The \"substitution\" combinator. Applies the last argument to the first two,\nand then the first two to each other.\n\n## Examples\n\n    iex> add = &(&1 + &2)\n    ...> double = &(&1 * 2)\n    ...> s(add, double, 8)\n    24\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:93","signature":[["x",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:93","signature":[["x",[],null],["y",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/ski.ex:93","signature":[["x",[],null],["y",[],null],["z",[],null]],"object_type":"FunctionObject","name":"s","module_id":"Quark.SKI","id":"s/3","doc":null,"arity":3},{"type":"def","source":"lib/quark/ski.ex:60","signature":[],"object_type":"FunctionObject","name":"second","module_id":"Quark.SKI","id":"second/0","doc":"Opposite of `first` (the `k` combinator).\n\nWhile not strictly part of SKI, it's a common enough case.\n\nReturns the *second* of two arguments. Can be used to repeatedly apply\nthe same value in functions such as folds.\n\n## Examples\n\n    iex> second(43, 42)\n    42\n\n    iex> Enum.reduce([1,2,3], [], &second/2)\n    []\n\n","arity":0},{"type":"def","source":"lib/quark/ski.ex:78","signature":[["a",[],null]],"object_type":"FunctionObject","name":"second","module_id":"Quark.SKI","id":"second/1","doc":null,"arity":1},{"type":"def","source":"lib/quark/ski.ex:78","signature":[["a",[],null],["b",[],null]],"object_type":"FunctionObject","name":"second","module_id":"Quark.SKI","id":"second/2","doc":null,"arity":2},{"type":"def","source":"lib/quark/sequence.ex:1","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__protocol__","module_id":"Quark.Sequence","id":"__protocol__/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:1","signature":[["data",[],null]],"object_type":"FunctionObject","name":"impl_for","module_id":"Quark.Sequence","id":"impl_for/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:1","signature":[["data",[],null]],"object_type":"FunctionObject","name":"impl_for!","module_id":"Quark.Sequence","id":"impl_for!/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:6","signature":[["specimen",[],null]],"object_type":"FunctionObject","name":"origin","module_id":"Quark.Sequence","id":"origin/1","doc":"The beginning of the sequence.\n\nFor instance, integers are generally thought of as centering around 0.\n\n## Examples\n\n    iex> origin(9)\n    0\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:37","signature":[["element",[],null]],"object_type":"FunctionObject","name":"pred","module_id":"Quark.Sequence","id":"pred/1","doc":"The `pred`essor in the sequence.\n\nFor integers, this is the number below.\n\n## Examples\n\n    iex> pred(10)\n    9\n\n    iex> 42 |> origin |> pred |> pred\n    -2\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:20","signature":[["element",[],null]],"object_type":"FunctionObject","name":"succ","module_id":"Quark.Sequence","id":"succ/1","doc":"The `succ`essor in sequence.\n\nFor integers, this is the number above.\n\n## Examples\n\n    iex> succ(1)\n    2\n\n    iex> 10 |> origin |> succ |> succ\n    2\n\n","arity":1},{"type":"def","source":"lib/quark/sequence.ex:55","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Quark.Sequence.Integer","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:56","signature":[["num",[],null]],"object_type":"FunctionObject","name":"origin","module_id":"Quark.Sequence.Integer","id":"origin/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:58","signature":[["num",[],null]],"object_type":"FunctionObject","name":"pred","module_id":"Quark.Sequence.Integer","id":"pred/1","doc":false,"arity":1},{"type":"def","source":"lib/quark/sequence.ex:57","signature":[["num",[],null]],"object_type":"FunctionObject","name":"succ","module_id":"Quark.Sequence.Integer","id":"succ/1","doc":false,"arity":1}],"language":"elixir","git_repo_url":"https://github.com/robot-overlord/quark.git","client_version":"0.5.3","client_name":"inch_ex","branch_name":"master","args":[]}